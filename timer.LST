C51 COMPILER V9.52.0.0   TIMER                                                             10/18/2018 17:40:32 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN timer.OBJ
COMPILER INVOKED BY: C:\Program Files\C51\BIN\C51.EXE timer.c LARGE BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          
   2          /*------------------------------------------------------------------*/
   3          /* --- STC MCU International Limited -------------------------------*/
   4          /* --- STC 1T Series MCU RC Demo -----------------------------------*/
   5          /* --- Mobile: (86)13922805190 -------------------------------------*/
   6          /* --- Fax: 86-0513-55012956,55012947,55012969 ---------------------*/
   7          /* --- Tel: 86-0513-55012928,55012929,55012966 ---------------------*/
   8          /* --- Web: www.GXWMCU.com -----------------------------------------*/
   9          /* --- QQ:  800003751 ----------------------------------------------*/
  10          /* If you want to use the program or the program referenced in the  */
  11          /* article, please specify in which data and procedures from STC    */
  12          /*------------------------------------------------------------------*/
  13          
  14          /*************  ¹¦ÄÜËµÃ÷  **************
  15          
  16          ±¾ÎÄ¼þÎªSTC8xxxÏµÁÐµÄ¶¨Ê±Æ÷³õÊ¼»¯ºÍÖÐ¶Ï³ÌÐò,ÓÃ»§¿ÉÒÔÔÚÕâ¸öÎÄ¼þÖÐÐÞ¸Ä×Ô¼ºÐèÒªµÄÖÐ¶Ï³ÌÐò.
  17          
  18          
  19          ******************************************/
  20          
  21          
  22          #include  "timer.h"
  23          
  24          u16 time_count;
  25          
  26          /********************* Timer0ÖÐ¶Ïº¯Êý************************/
  27          void timer0_int (void) interrupt TIMER0_VECTOR
  28          {
  29   1        //Èç²»ÊÇ×Ô¶¯ÖØ×°Ä£Ê½, Çë×ÔÐÐÌí¼Ó×°³õÖµµÄ´úÂë
  30   1        if(time_count++ > 65535)
  31   1          time_count = 0;
  32   1      }
  33          
  34          /********************* Timer1ÖÐ¶Ïº¯Êý************************/
  35          void timer1_int (void) interrupt TIMER1_VECTOR
  36          {
  37   1        //Èç²»ÊÇ×Ô¶¯ÖØ×°Ä£Ê½, Çë×ÔÐÐÌí¼Ó×°³õÖµµÄ´úÂë
  38   1        if(get_mode(ADC_END))
  39   1        {
  40   2          reset_mode(ADC_END);
  41   2          ADC_Send_Current();
  42   2          INA_Process();
  43   2          INA_Send_Current();
  44   2          reset_mode(VC_TEST);
  45   2        }
  46   1      }
  47          
  48          /********************* Timer2ÖÐ¶Ïº¯Êý************************/
  49          void timer2_int (void) interrupt TIMER2_VECTOR
  50          {
  51   1        P22 = ~P22;
  52   1      }
  53          
  54          /********************* Timer3ÖÐ¶Ïº¯Êý************************/
  55          void timer3_int (void) interrupt TIMER3_VECTOR
C51 COMPILER V9.52.0.0   TIMER                                                             10/18/2018 17:40:32 PAGE 2   

  56          {
  57   1        P23 = ~P23;
  58   1      }
  59          
  60          /********************* Timer4ÖÐ¶Ïº¯Êý************************/
  61          void timer4_int (void) interrupt TIMER4_VECTOR
  62          {
  63   1        P24 = ~P24;
  64   1      }
  65          
  66          //========================================================================
  67          // º¯Êý: u8 Timer_Inilize(u8 TIM, TIM_InitTypeDef *TIMx)
  68          // ÃèÊö: ¶¨Ê±Æ÷³õÊ¼»¯³ÌÐò.
  69          // ²ÎÊý: TIMx: ½á¹¹²ÎÊý,Çë²Î¿¼timer.hÀïµÄ¶¨Òå.
  70          //       ÌØ±ðËµÃ÷:  TIM_ValueMode=COUNTERÊ±,   TIM_ValueµÄÖµÎª¶ÔÍâ¼ÆÊýµÄ³õÖµ, 1TÄ£Ê½.
  71          //          TIM_ValueMode=TIME_usÊ±,   TIM_ValueµÄÖµÎª¶¨Ê±usÊý, Êµ¼Ê×°ÈëÊ±ÊÇ65536¼õ¶¨Ê±Öµ, ×Ô¶¯ÅÐ¶Ï12T»ò1TÄ£Ê½.
  72          //          TIM_ValueMode=SYS_CLOCKÊ±, TIM_ValueµÄÖµÎª¶¨Ê±ÏµÍ³Ê±ÖÓÊý, Êµ¼Ê×°ÈëÊ±ÊÇ65536¼õ¶¨Ê±Öµ, ×Ô¶¯ÅÐ¶Ï12T»ò1
             -TÄ£Ê½.
  73          // ·µ»Ø: 0: ³õÊ¼»¯³É¹¦,    1: ¶¨Ê±Æ÷ÐòºÅ¹ý´ó´íÎó,   2: Öµ¹ý´ó´íÎó.
  74          // °æ±¾: V1.0, 2018-3-22
  75          //========================================================================
  76          u8  Timer_Inilize(u8 TIM, TIM_InitTypeDef *TIMx)
  77          {
  78   1        u8  div12;
  79   1        if(TIM > Timer4)  return 1; //¶¨Ê±Æ÷ÐòºÅ¹ý´ó´íÎó
  80   1      
  81   1        if(TIMx->TIM_ValueMode == COUNTER)  //ÖØ×°ÖµÎª¶ÔÍâ¼ÆÊý³õÖµ, ¹Ì¶¨Îª1T¼ÆÊýÄ£Ê½
  82   1        {
  83   2          if(TIMx->TIM_Value >= 65536UL)  return 2; //Öµ¹ý´ó, ·µ»Ø´íÎó
  84   2          div12 = 0;    //1T mode
  85   2        }
  86   1        else  //ÖØ×°ÖµÎªus»òÏµÍ³Ê±ÖÓÊý
  87   1        {
  88   2          if(TIMx->TIM_ValueMode == TIME_us)    //ÖØ×°ÖµÎªus
  89   2            TIMx->TIM_Value = (u32)(((float)MAIN_Fosc * (float)TIMx->TIM_Value)/1000000UL); //ÖØ×°µÄÊÇÊ±¼ä(us), ¼ÆË
             -ãËùÐèÒªµÄÏµÍ³Ê±ÖÓÊý.
  90   2      
  91   2          if(TIMx->TIM_Value >= (65536UL * 12)) return 2; //Öµ¹ý´ó, ·µ»Ø´íÎó
  92   2          if(TIMx->TIM_Value < 65536UL) div12 = 0;    //1T mode
  93   2          else
  94   2          {
  95   3            div12 = 1;  //12T mode
  96   3            TIMx->TIM_Value = TIMx->TIM_Value / 12;
  97   3          }
  98   2        }
  99   1      
 100   1        if(TIM == Timer0)
 101   1        {
 102   2          if(TIMx->TIM_Mode >  TIM_16BitAutoReloadNoMask) return 3; //Ä£Ê½´íÎó
 103   2          TR0 = 0;  //Í£Ö¹¼ÆÊý
 104   2          ET0 = 0;  //½ûÖ¹ÖÐ¶Ï
 105   2          PT0 = 0;  //µÍÓÅÏÈ¼¶ÖÐ¶Ï
 106   2          TMOD &= 0xf0; //¶¨Ê±Ä£Ê½, 16Î»×Ô¶¯ÖØ×°
 107   2          AUXR &= ~0x80;  //12TÄ£Ê½, 
 108   2          INT_CLKO &= ~0x01;  //²»Êä³öÊ±ÖÓ
 109   2          if(TIMx->TIM_Interrupt == ENABLE)   ET0 = 1;  //ÔÊÐíÖÐ¶Ï
 110   2          if(TIMx->TIM_Polity == PolityHigh)    PT0 = 1;  //¸ßÓÅÏÈ¼¶ÖÐ¶Ï
 111   2          if(TIMx->TIM_ClkOut == ENABLE)  INT_CLKO |=  0x01;  //Êä³öÊ±ÖÓ
 112   2          TMOD |= TIMx->TIM_Mode; //¹¤×÷Ä£Ê½,0: 16Î»×Ô¶¯ÖØ×°, 1: 16Î»¶¨Ê±/¼ÆÊý, 2: 8Î»×Ô¶¯ÖØ×°, 3: 16Î»×Ô¶¯ÖØ×°, ²
             -»¿ÉÆÁ±ÎÖÐ¶Ï
 113   2          if(TIMx->TIM_ValueMode == COUNTER)    //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 114   2          {
C51 COMPILER V9.52.0.0   TIMER                                                             10/18/2018 17:40:32 PAGE 3   

 115   3            TMOD |=  0x04;  //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 116   3            if((TIMx->TIM_Mode == TIM_8BitAutoReload) && (TIMx->TIM_Value >= 256))  return 2; //Öµ¹ý´ó, ·µ»Ø´íÎó  8Î
             -»ÖØ×°Ä£Ê½
 117   3          }
 118   2          if(TIMx->TIM_Mode == TIM_8BitAutoReload)  //¶¨Ê±Æ÷8Î»ÖØ×°Ä£Ê½
 119   2          {
 120   3            if((div12 == 1) || (TIMx->TIM_Value >= (256 * 12))) return 2; //12TÄ£Ê½, Öµ¹ý´ó, ·µ»Ø´íÎó
 121   3            else if(TIMx->TIM_Value > 256)  TIMx->TIM_Value = TIMx->TIM_Value / 12; //12T
 122   3            else AUXR |=  0x80; //¶¨Ê±Æ÷, 1TÄ£Ê½
 123   3            if(TIMx->TIM_ValueMode != COUNTER)  TIMx->TIM_Value = 256 - TIMx->TIM_Value;  //¶¨Ê±Ä£Ê½
 124   3            TH0 = (u8)(TIMx->TIM_Value);
 125   3            TL0 = (u8)(TIMx->TIM_Value);
 126   3          }
 127   2          else  //¶¨Ê±Æ÷16Î»Ä£Ê½
 128   2          {
 129   3            if(div12 == 0)    AUXR |=  0x80;  //¶¨Ê±Æ÷, 1TÄ£Ê½  
 130   3            if(TIMx->TIM_ValueMode != COUNTER)  TIMx->TIM_Value = 65536UL - TIMx->TIM_Value;  //¶¨Ê±Ä£Ê½
 131   3            TH0 = (u8)(TIMx->TIM_Value >> 8);
 132   3            TL0 = (u8)(TIMx->TIM_Value);
 133   3          }
 134   2          if(TIMx->TIM_Run == ENABLE) TR0 = 1;  //¿ªÊ¼ÔËÐÐ
 135   2          return  0;    //³É¹¦
 136   2        }
 137   1      
 138   1        if(TIM == Timer1)
 139   1        {
 140   2          if(TIMx->TIM_Mode >= TIM_16BitAutoReloadNoMask) return 2; //´íÎó
 141   2          TR1 = 0;  //Í£Ö¹¼ÆÊý
 142   2          ET1 = 0;  //½ûÖ¹ÖÐ¶Ï
 143   2          PT1 = 0;  //µÍÓÅÏÈ¼¶ÖÐ¶Ï
 144   2          TMOD &=  0x0f;  //¶¨Ê±Ä£Ê½, 16Î»×Ô¶¯ÖØ×°
 145   2          AUXR &= ~0x40;  //12TÄ£Ê½, 
 146   2          INT_CLKO &= ~0x02;  //²»Êä³öÊ±ÖÓ
 147   2          if(TIMx->TIM_Interrupt == ENABLE)   ET1 = 1;  //ÔÊÐíÖÐ¶Ï
 148   2          if(TIMx->TIM_Polity == PolityHigh)    PT1 = 1;  //¸ßÓÅÏÈ¼¶ÖÐ¶Ï
 149   2          if(TIMx->TIM_ClkOut == ENABLE)  INT_CLKO |=  0x02;  //Êä³öÊ±ÖÓ
 150   2          TMOD |= (TIMx->TIM_Mode << 4);  //¹¤×÷Ä£Ê½,0: 16Î»×Ô¶¯ÖØ×°, 1: 16Î»¶¨Ê±/¼ÆÊý, 2: 8Î»×Ô¶¯ÖØ×°
 151   2          if(TIMx->TIM_ValueMode == COUNTER)    //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 152   2          {
 153   3            TMOD |=  0x40;  //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 154   3            if((TIMx->TIM_Mode == TIM_8BitAutoReload) && (TIMx->TIM_Value >= 256))  return 2; //Öµ¹ý´ó, ·µ»Ø´íÎó  8Î
             -»ÖØ×°Ä£Ê½
 155   3          }
 156   2          if(TIMx->TIM_Mode == TIM_8BitAutoReload)  //¶¨Ê±Æ÷8Î»ÖØ×°Ä£Ê½
 157   2          {
 158   3            if((div12 == 1) || (TIMx->TIM_Value >= (256 * 12))) return 2; //12TÄ£Ê½, Öµ¹ý´ó, ·µ»Ø´íÎó
 159   3            else if(TIMx->TIM_Value > 256)  TIMx->TIM_Value = TIMx->TIM_Value / 12; //12T
 160   3            else AUXR |=  0x40; //¶¨Ê±Æ÷, 1TÄ£Ê½
 161   3            if(TIMx->TIM_ValueMode != COUNTER)  TIMx->TIM_Value = 256 - TIMx->TIM_Value;  //¶¨Ê±Ä£Ê½
 162   3            TH1 = (u8)(TIMx->TIM_Value);
 163   3            TL1 = (u8)(TIMx->TIM_Value);
 164   3          }
 165   2          else  //¶¨Ê±Æ÷16Î»Ä£Ê½
 166   2          {
 167   3            if(div12 == 0)    AUXR |=  0x40;  //¶¨Ê±Æ÷, 1TÄ£Ê½  
 168   3            if(TIMx->TIM_ValueMode != COUNTER)  TIMx->TIM_Value = 65536UL - TIMx->TIM_Value;  //¶¨Ê±Ä£Ê½
 169   3            TH1 = (u8)(TIMx->TIM_Value >> 8);
 170   3            TL1 = (u8)(TIMx->TIM_Value);
 171   3          }
 172   2      
 173   2          if(TIMx->TIM_Run == ENABLE) TR1 = 1;  //¿ªÊ¼ÔËÐÐ
 174   2          return  0;    //³É¹¦
C51 COMPILER V9.52.0.0   TIMER                                                             10/18/2018 17:40:32 PAGE 4   

 175   2        }
 176   1      
 177   1        if(TIM == Timer2)   //Timer2,¹Ì¶¨Îª16Î»×Ô¶¯ÖØ×°, ÖÐ¶ÏÎÞÓÅÏÈ¼¶
 178   1        {
 179   2          AUXR &= ~0x1c;    //Í£Ö¹¼ÆÊý, ¶¨Ê±Ä£Ê½, 12TÄ£Ê½
 180   2          IE2  &= ~(1<<2);  //½ûÖ¹ÖÐ¶Ï
 181   2          INT_CLKO &= ~0x04;  //²»Êä³öÊ±ÖÓ
 182   2          if(TIMx->TIM_Interrupt == ENABLE) IE2  |=  (1<<2);  //ÔÊÐíÖÐ¶Ï
 183   2          if(TIMx->TIM_ClkOut == ENABLE)  INT_CLKO |=  0x04;    //Êä³öÊ±ÖÓ
 184   2          if(TIMx->TIM_ValueMode == COUNTER)  AUXR |=  (1<<3);  //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 185   2          if(div12 == 0)            AUXR |=  (1<<2);  //1TÄ£Ê½
 186   2          if(TIMx->TIM_ValueMode != COUNTER)  TIMx->TIM_Value = 65536UL - TIMx->TIM_Value;  //¶¨Ê±Ä£Ê½
 187   2          TH2 = (u8)(TIMx->TIM_Value >> 8);
 188   2          TL2 = (u8)(TIMx->TIM_Value);
 189   2          if(TIMx->TIM_Run == ENABLE) AUXR |=  (1<<4);  //¿ªÊ¼ÔËÐÐ
 190   2          return  0;    //³É¹¦
 191   2        }
 192   1      
 193   1        if(TIM == Timer3)   //Timer3,¹Ì¶¨Îª16Î»×Ô¶¯ÖØ×°, ÖÐ¶ÏÎÞÓÅÏÈ¼¶
 194   1        {
 195   2          T4T3M &= 0xf0;    //Í£Ö¹¼ÆÊý, ¶¨Ê±Ä£Ê½, 12TÄ£Ê½, ²»Êä³öÊ±ÖÓ
 196   2          IE2  &= ~(1<<5);  //½ûÖ¹ÖÐ¶Ï
 197   2          if(TIMx->TIM_Interrupt == ENABLE) IE2   |=  (1<<5); //ÔÊÐíÖÐ¶Ï
 198   2          if(TIMx->TIM_ClkOut == ENABLE)    T4T3M |=  1;    //Êä³öÊ±ÖÓ
 199   2          if(TIMx->TIM_ValueMode == COUNTER)  T4T3M |=  (1<<2); //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 200   2          if(div12 == 0)            T4T3M |=  (1<<1); //1TÄ£Ê½
 201   2          if(TIMx->TIM_ValueMode != COUNTER)  TIMx->TIM_Value = 65536UL - TIMx->TIM_Value;  //¶¨Ê±Ä£Ê½
 202   2          TH3 = (u8)(TIMx->TIM_Value >> 8);
 203   2          TL3 = (u8)(TIMx->TIM_Value);
 204   2          if(TIMx->TIM_Run == ENABLE) T4T3M |=  (1<<3); //¿ªÊ¼ÔËÐÐ
 205   2          return  0;    //³É¹¦
 206   2        }
 207   1      
 208   1        if(TIM == Timer4)   //Timer4,¹Ì¶¨Îª16Î»×Ô¶¯ÖØ×°, ÖÐ¶ÏÎÞÓÅÏÈ¼¶
 209   1        {
 210   2          T4T3M &= 0x0f;    //Í£Ö¹¼ÆÊý, ¶¨Ê±Ä£Ê½, 12TÄ£Ê½, ²»Êä³öÊ±ÖÓ
 211   2          IE2  &= ~(1<<6);  //½ûÖ¹ÖÐ¶Ï
 212   2          if(TIMx->TIM_Interrupt == ENABLE) IE2   |=  (1<<6); //ÔÊÐíÖÐ¶Ï
 213   2          if(TIMx->TIM_ClkOut == ENABLE)    T4T3M |=  (1<<4); //Êä³öÊ±ÖÓ
 214   2          if(TIMx->TIM_ValueMode == COUNTER)  T4T3M |=  (1<<6); //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 215   2          if(div12 == 0)            T4T3M |=  (1<<5); //1TÄ£Ê½
 216   2          if(TIMx->TIM_ValueMode != COUNTER)  TIMx->TIM_Value = 65536UL - TIMx->TIM_Value;  //¶¨Ê±Ä£Ê½
 217   2          TH4 = (u8)(TIMx->TIM_Value >> 8);
 218   2          TL4 = (u8)(TIMx->TIM_Value);
 219   2          if(TIMx->TIM_Run == ENABLE) T4T3M |=  (1<<7); //¿ªÊ¼ÔËÐÐ
 220   2          return  0;    //³É¹¦
 221   2        }
 222   1      
 223   1        return 2; //´íÎó
 224   1      }
 225          
 226          
 227          u16 get_time(void)
 228          {
 229   1        return time_count;
 230   1      }
 231          
 232          u8 timeout_nms(u16 timeout, u16 starttime)
 233          {
 234   1        if(time_count < starttime)
 235   1          if((time_count + 65536 - starttime) > timeout)
 236   1            return 1;
C51 COMPILER V9.52.0.0   TIMER                                                             10/18/2018 17:40:32 PAGE 5   

 237   1          else
 238   1            return 0;
 239   1        else
 240   1          if((time_count - starttime) > timeout)
 241   1            return 1;
 242   1          else
 243   1            return 0;
 244   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2036    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
